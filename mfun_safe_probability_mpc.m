function [p, LfP, LgP, BP] = mfun_safe_probability_mpc(x_ini, Dis_k, Dis_pre, dt, snum, horizon)
% Implementation of MATLAB Function for calculating 
% safe probability by Monte Carlo simulation 
%
% DO NOT EDIT THIS FILE to implement the plant and controllerdynamics.
% Edit "fun_f.m", "fun_g.m", and "fun_sigma.m" instead for plant. 
% Edit "fun_nominal_controller.m" for nominal controller.

    % parameters
    paramMC.dt      = dt;
    paramMC.snum    = snum;
    paramMC.horizon = horizon;

    % nlmpc object 
    nlobj = nlmpc(12,3,2);    
    nlobj.Ts = dt;
    nlobj.PredictionHorizon = 10;
    nlobj.ControlHorizon = 2;    
    nlobj.Model.StateFcn =  @(x,u,xi) fun_f(x,xi) + fun_g(x)* u;
    nlobj.Model.OutputFcn = @(x,u,xi) [x(1);x(11);x(12)];
    nlobj.Model.NumberOfParameters = 1;
    nlobj.Weights.OutputVariables = [0.05 1 1];
    nlobj.Weights.ManipulatedVariablesRate = [0.1 0.1];
    
    % monte calro calculation
    p          = safe_probability(x_ini, paramMC, Dis_k, nlobj);
    [LfP, LgP] = grad_of_p(x_ini, paramMC, Dis_k); 
    BP         = p - safe_probability(x_ini, paramMC, Dis_pre);

end

function p = safe_probability(x_ini, paramMC, paramDis, nlobj)

    dt       = paramMC.dt;
    horizon  = paramMC.horizon;
    xi_mean  = paramDis(1);
    xi_sigma = sqrt(paramDis(2));
    samples  = ones(1, paramMC.snum);

    parfor i = 1:paramMC.snum

        x = x_ini;
        u = [0 0];
        xi = xi_mean + xi_sigma*randn;
        if xi < 0.1
            xi = 0.1;
        end
        nloptions = nlmpcmoveopt;
        nloptions.Parameters = {xi};

        for k = 1:horizon
            %u  = fun_nominal_controller(x);
            
            yref = [40*1000/3600 0 0];
            [u,nloptions] = nlmpcmove(nlobj,x,u,yref,[],nloptions);

            [~,y] = ode45( @(t,x) fun_f(x,xi)+fun_g(x)*u, [0,dt], x);  
            x = transpose( y(end,:) );

            % unsafe if barrier function go below 0
            if fun_safety_condition(x,xi) < 0 
                samples(i)   = 0;
                break
            end
        end
    end
    p = sum(samples)/paramMC.snum;

end

function [LfP, LgP] = grad_of_p(x, paramMC, paramDis)

    % Expectation of vector fields f(x)
    xi_mean  = paramDis(1);
    xi_sigma = sqrt(paramDis(2));
    fx_list = zeros(length(x),paramMC.snum);
    parfor i = 1:paramMC.snum
        xi = xi_mean + xi_sigma*randn;
        if xi < 0.01
            xi = 0.01;
        end
        fx_list(:,i) = fun_f(x, xi);
    end
    fx = mean(fx_list, 2);

    % Lie derivative of P along f(x)
    dt = 0.1;  %paramMC.dt * 0.1;
    df = fx*dt; 
    p_dfp = safe_probability(x+df, paramMC, paramDis);
    p_dfm = safe_probability(x-df, paramMC, paramDis);
    LfP  = (p_dfp - p_dfm)/(2*dt); 

    % Lie derivatives of P along each colum of g(x)
    gx     = fun_g(x);
    dim_gx = size(gx);
    numcol = dim_gx(2); % number of columns of g(x)
    LgP = zeros(1,numcol);
    for j = 1:numcol
        %dt = 1;
        dg = gx(:,j)*dt;
        p_dgp = safe_probability(x+dg, paramMC, paramDis);
        p_dgm = safe_probability(x-dg, paramMC, paramDis);
%         if p_dgp == 0
%             disp('safety probability becomes zero at gradient culculation: see "mfun_safe_probability_MC.m"')
%         end

        LgP(j) = (p_dgp - p_dgm)/(2*dt); 
    end

end